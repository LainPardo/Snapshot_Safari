
# This script contains some functions to use with the species report generated by Zooniverse
# and SNAPSHOT SAFARI Project.

#created by Lain Pardo in collaboration with Lisa Nicvert.


# FUNCTIONS INCLUDED: 

#  1. standardize names, columns, and filter non mammals (among others) 
#  2. get only independent records of 60 mins (this can be changed)
#  3. Calculate RAI and species number analysis (general reports)
#  4. put coordinates into the reports, create final outputs.. (some cols like cam.start and end day will 
#     depends on rolls and objective)
#  5. add the scientific name to each row
#  6. function to put digikam format to snapshot format
#  7. create detection histories
#  8. create standard procedure for biodiversity analysis
#  9. other simple but useful functions including general visualizations
# ...

library(dplyr)
library(lubridate)
library(tidyverse)
library(hrbrthemes)
library(viridis)


#  standardize names and tidy table ----------------------------------------


# Function to standardize names used for the same spp across
  # Zooniverse datasets.Some names will depend on the research, so change accordingly
  

# 1. standardize names of report

standardise_names <- function(df){
  
  # Define global variable to eliminate non species
  res <- df
  res$question__species <- as.character(res$question__species)
  res$question__species[res$question__species == "birdsofprey"] <- "birdofprey"
  res$question__species[res$question__species == "duiker"] <- "duikercommon"
  res$question__species[res$question__species == "duikercommongrey"] <- "duikercommon"
  res$question__species[res$question__species == "harecape"] <- "hare"
  res$question__species[res$question__species == "wildcat"] <- "catafricanwild" #
  res$question__species[res$question__species == "groundsquirrel"] <- "squirrelground"
  res$question__species[res$question__species == "mongoosewater"] <- "mongoosewatermarsh"
  res$question__species[res$question__species == "mongoosecapesmallgrey"] <- "mongoosesmallcapegrey"
  res$question__species[res$question__species == "mongooseegyptianlargegrey"] <- "mongooselargegrey"
  res$question__species[res$question__species == "mongoose(whitetailed)"] <- "mongoosewhitetailed"
  res$question__species[res$question__species == "NOT identifiable"] <- "unresolvable"
  res$question__species[res$question__species == "Unidentifiable"] <- "unresolvable"
  res$question__species[res$question__species == "unidentifiable"] <- "unresolvable"
  res$question__species[res$question__species == "UNIDENTIFIED"] <- "unresolvable"
  res$question__species[res$question__species == "lionmale"] <- "lion"
  res$question__species[res$question__species == "lionfemale"] <- "lion"
  res$question__species[res$question__species == "lioncub"] <- "lion"
  res$question__species[res$question__species == "springhare"] <- "harespring"
  res$question__species[res$question__species == "zorillastripedpolecat"] <- "polecatstriped"
  res$question__species[res$question__species == "rhino"] <- "rhinoceros"
  res$question__species[res$question__species == "lionfemaleorcub"] <- "lion"
  res$question__species[res$question__species == "zorillapolecatstriped"] <- "polecatstriped"
  res$question__species[res$question__species == "genetlargespotted"] <- "genetcapelargespotted"
  res$question__species[res$question__species == "genet(small)"] <- "genetcommonsmallspotted"
  res$question__species[res$question__species == "genetcape"] <- "genetcapelargespotted"
  res$question__species[res$question__species == "rhinocerossp"] <- "rhinoceros"
  res$question__species[res$question__species == "genetsmallspotted"] <- "genetcommonsmallspotted"
  res$question__species[res$question__species == "galagosouthernlesser"] <- "bushbaby"
  res$question__species[res$question__species == "aardvark"] <- "aardvarkantbear"
  res$question__species[res$question__species == "duiker"] <- "duikercommon"
  res$question__species[res$question__species == "grysbok"] <- "grysbokcape"
  res$question__species[res$question__species == "rodents"] <- "rodent"
  res$question__species[res$question__species == "rhebok (grey)"] <- "rhebokgrey"
  res$question__species[res$question__species == "unknown"] <- "unresolvable"
  res$question__species[res$question__species == "Africanwildcat"] <- "catafricanwild"
 
  return(res)
}

## 2. clean table defining two more arguments: bycatch and pres/absence 

clean_table <- function(df, rm_bycatch = TRUE, pres_abs = TRUE){
  
  # Define global variable to eliminate non species
  NOT_SPP <- c("fire", "1", "0","", "1.0", "0.0", "unknown", "unresolvable", "noanimalpresent",
               "not present", "blank")
  BYCATCH <- c("birdofprey", "birdother", "bustardkori", "bustardludwigs", "guineafowl",
               "squirreltree", "reptilesamphibians", "human", "bustarddenhams",
               "secretarybird","tortoise", "domesticanimal", "ostrich", "bat", "reptilesamphibians",
               "fowlguinea","spider", "reptile", "insect", "bustardludwig's","craneblue", "horse")
  
  # Clean datatable.
  # rm_bycatch: should the spp defined as bycatch be included?
  # pres_abs: should the data be transformed to presence/absence before aggregating?
  
  # Merge spp with the same names
  res <- df
  
  res$capture_date_local <- as.Date(res$capture_date_local)
  
  # Convert factors to characters to modify
 res$question__count_max <- as.character(res$question__count_max)
 res$question__count_median <- as.character(res$question__count_median)
 res$question__count_min <- as.character(res$question__count_min)
  
  # Replace 51+ by 11 (if precise number of individuals are needed then do it manually from report
 #and cancel this part of the script)
  rep = "11"
  res$question__count_max[res$question__count_max == "51+"] <- rep
  res$question__count_median[res$question__count_median == "51+"] <- rep
  res$question__count_min[res$question__count_min == "51+"] <- rep
  
  #Replace 11-50 by 11
  rep2 = "11"
  res$question__count_max[res$question__count_max == "11-50"] <- rep2
  res$question__count_median[res$question__count_median =="11-50"] <- rep2
  res$question__count_min[res$question__count_min == "11-50"] <- rep2
  
  # replace "Nov-50" 
  res$question__count_max[res$question__count_max ==  "Nov-50"] <- rep2
  res$question__count_median[res$question__count_median == "Nov-50"] <- rep2
  res$question__count_min[res$question__count_min ==  "Nov-50"] <- rep2
  
  
  # Convert back to numeric
  res$question__count_max <- as.numeric(res$question__count_max)
  res$question__count_median <- as.numeric(res$question__count_median)
  res$question__count_min <- as.numeric(res$question__count_min)
  
  # Dates and times
  res$capture_date_local <- as.Date(res$capture_date_local)
  res$DateTimeOriginal <- as.POSIXct(res$DateTimeOriginal)
  res$DateTimeOriginal <- force_tz(res$DateTimeOriginal, tz = "Etc/GMT-2")
 
  # Fire and co
  res <- filter(res,
                !(question__species %in% NOT_SPP))
  # Remove non mammals 
  if(rm_bycatch){
    res <- filter(res,
                  !(question__species %in% BYCATCH))
  }
  # Convert to presence/absence data
  if(pres_abs){
    res <- mutate(res, 
                  question__count_median = ifelse(question__count_median > 1,
                                                  1,question__count_median))
  }
  
  res$question__species <- as.factor(res$question__species)
  
  return(res)
}


# 3. INDEPENDENCE CRITERIA ---------------------------------------------------

indep60 <- function(df.clean){
  # unique ID
  #df.clean <- df.clean %>% dplyr::arrange(site, DateTimeOriginal)
  df.clean$row_id <- 1:nrow(df.clean)
  
  # Filtering timestep
  timestep <-dminutes(60)   #change to any threshold in minutes (e.g. 30)
  
  # Initialise results table
  df.filtered <- df.clean
  
  for(i in 1:nrow(df.clean)){ # iterate over each rows of initial table
    
    row <- df.clean[i,] # for each row of raw counts
    
    int <- interval(row$DateTimeOriginal, row$DateTimeOriginal + timestep)
    # compute the interval in which we want to remove similar sightings
    
    if(row$row_id %in% df.filtered$row_id){ # if the picture has not been removed already
      
      # Get the same species at the same site etc
      # (including first observation, ie "row")
      observed.in.int <- df.filtered %>% filter(DateTimeOriginal %within% int
                                                & site == row$site
                                                & question__species == row$question__species)
      
      # df.clean if there are records of the same species
      if(nrow(observed.in.int) > 1){ # If row is not the only one, we want to filter
        # Get max species count (integer) within the same spp at same site
        maxi <- max(observed.in.int$question__count_median)
        
        # Get the good row (with max spp count)
        row.to.keep <- observed.in.int %>% filter(question__count_median == maxi)
        
        # df.clean if several rows have the same maximal species count
        if(nrow(row.to.keep) > 1){ 
          # Choose one of the rows randomly
          id <- sample(row.to.keep$row_id, size = 1) # sample random id
          row.to.keep <- row.to.keep %>% filter(row_id == id)
        }else{ # Only one row has max spp count, keep it
          id <- row.to.keep$row_id
        }
        
        # Get the ids to remove (ie all candidate pictures observed in interval,
        # except the row to keep)
        rows.to.remove <- observed.in.int %>% filter(row_id != id)
        
        # df.clean if more than one row to remove
        if(nrow(rows.to.remove) > 1){ # more than one row -> use %in%
          df.filtered <- df.filtered %>% filter(!(row_id %in% rows.to.remove$row_id)) 
        }else{ # exactly one row -> use !=
          df.filtered <- df.filtered %>% filter(row_id != rows.to.remove$row_id) 
        }
      }
    }
  }
  return(df.filtered)
}


# defining final columns from reports -------------------------------------


# 4_ select variables of interest and change name col (original report +new cols is the df used)

cols_need <- function(df){
  df <- select(df, "code_loc","site_ID", "question__species","Scientific.Name","capture_date_local",
               "capture_time_local", "question__count_median", "subject_id", "season1", "roll",
               "zooniverse_url_0", "zooniverse_url_1","zooniverse_url_2", "p_users_identified_this_species", 
               "DateTimeOriginal")
  
  names(df) <- c("Reserve.Location", "Camera.Site", "Common.Name","Scientific.Name","Photo.Date",
                  "Photo.Time","Number.of.Individuals","Photo.ID", "Season","Roll",
                 "Zooniverse.Url.1","Zooniverse.Url.2", "Zooniverse.Url.3","Consensus", 
                 "DateTimeOriginal")
  
  df$Photo.Date <- as.POSIXct(df$Photo.Date, format="%Y-%m-%d") 
  df$DateTimeOriginal <- as.POSIXct(df$DateTimeOriginal)
  
  return(df)
}


# start-end date reports --------------------------------------------------


# getting the start end date of surveys of final df of species records (report fixed with independence etc)

survey_period <- function(spp_rec){
  a <- spp_rec %>% 
    group_by(Camera.Site) %>% 
    summarise(First.Photo.Date = min(Photo.Date),
              Last.Photo.Date = max(Photo.Date))
  
  #create a col with the effor (cam.days)
  a2 <- a %>% mutate(
    Act.Days = a$Last.Photo.Date - a$First.Photo.Date)
  
  return(a2)
}

# if start date is clear leave the "Setup.Date" then complete cols manually in script
survey_period2 <- function(spp_rec){
  a <- spp_rec %>% 
    group_by(Camera.Site) %>% 
    summarise(Last.Photo.Date = max(Photo.Date))
    
  return(a)
}

# # number of species per station from report 2 ---------------------------


spp_station_r2 <- function(r2){
  ggplot(r2, aes(x=reorder(Camera.Site, -n_species), y=n_species)) +
    geom_bar(stat = "identity") + 
    theme(axis.text.x  = element_text(angle = 90,hjust = 1, vjust = 0.5)) +
    ggtitle("Number of species per camera") +
    labs(y="Number of species", x = "Camera sites")
}


# # number of station per species from report 3 ---------------------------


station_spp_r3 <- function(r3){
  r3$species<- as.factor(r3$species)  #we need the x ax to be factor
  r3$n_stations <- as.integer(r3$n_stations) #we need y as integers
  r3$species <- reorder(r3$species, -r3$n_stations, FUN=sum)
  
  fig <-ggplot(r3, aes(x=species, y=n_stations)) +
    geom_bar(stat = "identity") + 
    theme(axis.text.x  = element_text(angle = 90,hjust = 1, vjust = 0.5)) +
    ggtitle("Number of cameras per species") +
    labs(y="Number of cameras", x = "Species")
  
  return(fig)
}


#  number of events per station from rep 3 (NOT standardized by effort!--------


events_spp_r3 <- function(r3){
  r3$species<- as.factor(r3$species)  #we need the x ax to be factor
  r3$n_events <- as.integer(r3$n_events) #we need y as integers
  r3$species <- reorder(r3$species, -r3$n_events, FUN=sum)
  
  fig <-ggplot(r3, aes(x=species, y=n_events)) +
    geom_bar(stat = "identity") + 
    theme(axis.text.x  = element_text(angle = 90,hjust = 1, vjust = 0.5)) +
    ggtitle("Number of events (not std) per species") +
    labs(y="Number of events", x = "Species")
  
  return(fig)
}

#barplot with RAI genral from RAI_calc_table

RAI_gral_barplot <- function(RAI_calc_table){
  RAI_calc_table$Common.Name<- as.factor(RAI_calc_table$Common.Name)  #we need the x ax to be factor
  RAI_calc_table$RAI.Gral <- as.integer(RAI_calc_table$RAI.Gral ) #we need y as integers
  RAI_calc_table$Common.Name <- reorder(RAI_calc_table$Common.Name, -RAI_calc_table$RAI.Gral , FUN=sum)
  
  fig <-ggplot(RAI_calc_table, aes(x=Common.Name, y=RAI.Gral)) +
    geom_bar(stat = "identity") + 
    theme(axis.text.x  = element_text(angle = 90,hjust = 1, vjust = 0.5)) +
    ggtitle("RAI general per species") +
    labs(y="RAI general", x = "Species")
  
  return(fig)
}

# Fig spp richness --------------------------------------------------------

#input for this is she 2.#spp_by_station+coord.csv (see script reports if struggle)
fig_sp_richness <- function(merge.sites){
  
  e <-ggplot(mergesites, aes(Long_X, Lat_Y)) +
    geom_point(aes(size=n_species, colour=n_species),alpha=1) +
    scale_size_area() +
    ylab("Longitude") +
    xlab("Latitute") +
    guides(color= guide_legend("Species #"), size= guide_legend("Species #")) +
    scale_color_gradient(low = "skyblue", high = "blue") 
   
  l <- e + geom_text(aes(label=Camera.Site), size=2, vjust=2.3, color = "black") 
  
     #+
   # theme_ipsum()
  
  return(l)
}


#RAI() # genral for study are #### events (not real abundance col yet)
#APPLY TO THE new.mat object 1.camtrap_operation.csv + 5.#obs&notobsspp+#events_by_station

RAI_events <- function(new.mat){
  Tot_cameras <- with(new.mat, length(unique(Camera.Site))) #
  cam_site <- with(new.mat, tapply(Camera.Site, Common.Name, length)) # cams worked per spp
  days <- with(new.mat, tapply(n_nights_active, Common.Name, sum)) #sum is 1133, all spp the same, is this ok? 
  n <- with(new.mat, tapply(n_events, Common.Name, sum))   #correct
  RAIgral <- round(n/days*100, 2) 
  table.1 <- cbind(cam_site, days, n, RAIgral)
  #table.1 <- table.1[order(RAIgral),]  #organized in order of RAI
  
  #return(table.1)

# RAI correlations --------------------------------------------------------
#apply to new.mat

#RAI_correl <- function(new.dat){
  RAIalt <- with(new.mat, round((n_events/n_nights_active)*100, 2))
  RAImean <- with(new.mat, round(tapply(RAIalt, Common.Name, mean), 2))
  RAIsd <- with(new.mat, round(tapply(RAIalt, Common.Name, sd), 2))
  occ <- subset(new.mat, n_events > 0)  
  sites_Occ <- table(occ$Common.Name)
  OccNaive <- round(table(occ$Common.Name)/cam_site,2)
  table.3 <- cbind(RAImean, RAIsd, sites_Occ, OccNaive)
  #return(table3)
  table.fin <- cbind(table.1, table.3)#+RAImean,RAIsd,sites_Occ,OccNaive
  
  table_fin_df <-tibble::rownames_to_column(data.frame(table.fin))
  df_diversity_fin <- rename(table_fin_df, 
                             Common.Name = rowname,
                             Total.Cam.Sites = cam_site,
                             Total.Count = n,
                             Sites.Occ = sites_Occ,
                             Occ.Naive = OccNaive,
                             RAImean = RAImean,
                             RAI.sd = RAIsd,
                             RAI.Gral = RAIgral,
                             Cam.Days = days)
  return(df_diversity_fin)
}



# FIG RAI SELECTED SPP ----------------------------------------------------
#need RAIalt +lat.long table (which I merged as mergesites2 for reports)

fig_RAI_spp <- function(RAIaltdf, species){
  # Plot the relative abundances for a particular species (species)
  # RAIaltdf is a dataframe
  # species is a character (species' name)
  
  df.spp <- RAIaltdf %>% dplyr::filter(Common.Name == species)
  titlesp <- unique(df.spp$Common.Name)
  e <-ggplot(df.spp, aes(Long_X, Lat_Y, size =RAIalt, colour=RAIalt)) +
    geom_point(aes(size=RAIalt, colour=RAIalt),alpha=1) +
    scale_size_area() +
    ylab("Longitude") +
    xlab("Latitute") +
    guides(color= guide_legend(), size=guide_legend()) +
    scale_color_gradient(low = "skyblue", high = "blue") +
    ggtitle(paste0(titlesp)) 
  l <- e + geom_text(aes(label=Camera.Site), size=2, vjust=2.3, color = "black") #+theme_ipsum()
  
  return(l)
}






# function to put digikam format to snapshot format ---------------

#ROAMING SITES: REORDER DIGIKAM REPORTS TO MATCH FORMAT SNAPSHOT ---------
#input the original digikam report usually "code_sp_report_digikam_date.csv"

#insert col with reserve code

digi_snap <- function(digikamrep, sitecode){
   code_loc <-sitecode
   rep_AUG <- cbind(code_loc, digikamrep)
   rep_AUG1 <- unite(rep_AUG, Site_ID, code_loc, Station, sep = "_",remove = FALSE) #

#select cols

df <- select(rep_AUG1, code_loc, Site_ID, Species,Date,
             Time, metadata_Number, FileName, DateTimeOriginal)

#add those cols in snapshot not represented in Digikam and fill with NA

df[c("season1", "roll","zooniverse_url_0","zooniverse_url_1",
     "zooniverse_url_2", "p_users_identified_this_species")] = "NA"

# Reorder 

df_fin <- select(df, 1:7, 9:14,8)

# change col names (if donpt need to use other functions that use snapshot format like indep60)
#
names(df_fin) <- c("code_loc","site_ID", "question__species","capture_date_local",
            "capture_time_local", "question__count_median", "subject_id", "season1", "roll",
           "zooniverse_url_0", "zooniverse_url_1", "zooniverse_url_2",
           "p_users_identified_this_species", "DateTimeOriginal")

#use cols_need function to put corrected final names
return(df_fin)

}

# modified digi to snap code, KEEPING other columns of interest ------------------
#for the FBIP format, such as #behaviour and others
#input the original digikam report usually "code_sp_report_digikam_date.csv"

#insert col with reserve code

digi_snap2 <- function(digikamrep, sitecode){
  code_loc <-sitecode
  rep_AUG <- cbind(code_loc, digikamrep)
  rep_AUG1 <- unite(rep_AUG, Site_ID, code_loc, Station, sep = "_",remove = FALSE) #
  
  #select cols
  
  df <- select(rep_AUG1, code_loc, Site_ID, Date,
               Time, Species, metadata_Number, EXIF.Make, metadata_Behaviour, metadata_Sex, metadata_young_present,
               FileName, DateTimeOriginal)
  
  #add those cols in snapshot not represented in Digikam and fill with NA
  
  df[c("season1", "roll","zooniverse_url_0","zooniverse_url_1",
       "zooniverse_url_2", "p_users_identified_this_species")] = "NA"
  #names(df)
  # Reorder 
  
  df_fin <- select(df, 1:6, 8:10,7,11,13:18,12)
  
  # change col names (if donpt need to use other functions that use snapshot format like indep60)
  #
  names(df_fin) <- c("code_loc","site_ID", "capture_date_local", "capture_time_local",
                     "question__species","question__count_median", "metadata_Behaviour","metadata_Sex",
                     "metadata_young_present", "EXIF.Make", 
                     "subject_id", "season1", "roll",
                     "zooniverse_url_0", "zooniverse_url_1", "zooniverse_url_2",
                     "p_users_identified_this_species", "DateTimeOriginal")
  
  #use cols_need function to put corrected final names
  return(df_fin)
  
}

# # standardize any report coming from zooniverse format ------------------

#basically selecting and organizing cols as sometimes difered ...

cols_snap_std <- function(df){
  
  # --- Create an empty dataframe with the columns we need
  # The columns needed
  cols <- c("capture_id" ,"season","site", "roll","capture","capture_date_local","capture_time_local",
            "zooniverse_url_0","zooniverse_url_1", "zooniverse_url_2", "subject_id", "question__species",
            "question__count_max", "question__count_median", "question__count_min", "question__standing",
            "question__resting", "question__moving", "question__eating", "question__interacting", 
            "question__young_present", "question__horns_count_max", "question__horns_count_median",
            "question__horns_count_min","p_users_identified_this_species", "pielous_evenness_index")
  ncol <- length(cols) # number of columns
  
  
  # --- Create columns that don't exist 
  # Helper function to add columns that are not in the original data
  # (Code found on https://stackoverflow.com/questions/45857787/adding-column-if-it-does-not-exist)
  fncols <- function(data, cname) {
    # data = the dataframe to modify
    # cname = column names (character vector or character)
    res <- data
    add <- cname[!cname %in% names(data)]
    
    if(length(add)!=0){
      res[add] <- NA
    } 
    return(res)
  }
  
  df_res <- fncols(df, cols)
  
  
  # --- Reorder 
  df_fin <- df_res %>% select(all_of(cols)) # reorder in the same order as cols used before
  
  return(df_fin)
}




# end ---------------------------------------------------------------------

#rmarkdown::render("1_SNAPSHOT_source_functions.R") 






